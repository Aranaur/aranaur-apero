<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Science</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ігор Мірошниченко" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <script src="libs/freezeframe/freezeframe.min.js"></script>
    <script src="libs/xaringanExtra-freezeframe/freezeframe-init.js"></script>
    <script id="xaringanExtra-freezeframe-options" type="application/json">{"selector":"img[src$=\"gif\"]","trigger":"click","overlay":false,"responsive":true,"warnings":true}</script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/fabric/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30,"palette":[]}) })</script>
    <link href="libs/xaringanExtra-extra-styles/xaringanExtra-extra-styles.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Data Science
## Лекція 4: мова програмування R
### Ігор Мірошниченко
### ІІТЕ | ІК-301

---

name: toc

&lt;style type="text/css"&gt;
@media print {
  .has-continuation {
    display: block !important;
  }
}
&lt;/style&gt;



# Зміст

1. [Пролог](#prologue)

2. [Вступ](#intro)

3. [ООП в R](#oop)

4. ["Все є об'єктом"](#eobject)

5. ["Все має ім'я"](#ename)

6. [Індексація](#indexing)

7. [Очищення](#cleaning)

---
class: inverse, center, middle
name: prologue

# Пролог

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1100px&gt;&lt;/html&gt;

---

# Checklist

### Пакети, які вам знадобляться сьогодні.

Сьогодні ми будемо працювати майже виключно в **base** R.
- Я також буду використовувати пакет [**dplyr**](https://dplyr.tidyverse.org/), але лише для демонстрації кількох додаткових фішок щодо роботи з небазовими бібліотеками. Встановіть/оновіть його зараз або через RStudio (рекомендовано), або з консолі R (`install.packages("dplyr"), dependencies  = TRUE`).
- (P.S. Якщо ви використовуєте Linux, я рекомендую встановити попередньо скомпільовану бінарну версію **dplyr** з [RSPM](https://packagemanager.rstudio.com/client/#/repos/1/overview) . Це дозволяє уникнути необхідності створювати пакет із вихідного коду, що значно скорочує час встановлення. Див. відповідний приклад [тут](https://twitter.com/grant_mcdermott/status/1263951531461603328).)

---
class: inverse, center, middle
name: intro

# Вступ

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1100px&gt;&lt;/html&gt;

(Основні концепції R)

---

# Арифметика

R — потужний калькулятор, який розпізнає всі стандартні арифметичні оператори:


```r
1+2 ## Додавання
```

```
## [1] 3
```

```r
6-7 ## Віднімання
```

```
## [1] -1
```

```r
5/2 ## Ділення
```

```
## [1] 2.5
```

```r
2^3 ## Степінь
```

```
## [1] 8
```

```r
2+4*1^3 ## Стандартний порядок розрахунків (`*` спочатку `+`, потім)
```

```
## [1] 6
```

---

# Арифметика (прод.)

Ми також можемо викликати оператори за модулем (цілочисельне ділення та остача).
- Дуже корисно, наприклад, у роботі з часом.


```r
100 %/% 60 ## Скільки цілих годин у 100 хвилинах?
```

```
## [1] 1
```

```r
100 %% 60 ## Скільки хвилин залишилося?
```

```
## [1] 40
```

---

# Логічні операції

R також оснащений повним набором логічних операторів і булевих значень, які відповідають стандартному протоколу програмування. Наприклад:


```r
1 &gt; 2
```

```
## [1] FALSE
```

```r
1 &gt; 2 &amp; 1 &gt; 0.5 ## Знак "&amp;" відповідає за "та"
```

```
## [1] FALSE
```

```r
1 &gt; 2 | 1 &gt; 0.5 ## Знак "|" відповідає за "або"
```

```
## [1] TRUE
```

```r
isTRUE (1 &lt; 2)
```

```
## [1] TRUE
```

--

Докладніше про логічні оператори та типи можна прочитати &lt;a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/Logic.html" target="_blank"&gt;тут&lt; /a&gt; і &lt;a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/logical.html" target="_blank"&gt;тут&lt;/a&gt;. Однак у наступних кількох слайдах я хочу підкреслити деякі особливі концепції та проблеми...

---

# Логічні операції (прод.)

### Порядок пріоритету

Подібно до стандартної арифметики, логічні висловлювання мають суворий порядок пріоритету. Логічні оператори (`&gt;`, `==` тощо) оцінюються перед логічними операторами (`&amp;` та `|`). Якщо цього не розпізнати, це може призвести до несподіваної поведінки...


```r
1 &gt; 0.5 &amp; 2
```

```
## [1] TRUE
```

--

Тут відбувається те, що R оцінює два окремих «логічних» висловлювання:
  - `1 &gt; 0,5`, що, очевидно, є TRUE
  - `2`, що є TRUE(!), тому що R "корисно" перетворює його на `as.logical(2)`.
 
--

**Рішення.** Укажіть чітко кожен компонент вашого логічного оператора.


```r
1 &gt; 0.5 &amp; 1 &gt; 2
```

```
## [1] FALSE
```


---

# Логічні операції (прод.)

### Заперечення: `!`

Ми використовуємо `!` як заперечення. Це стане в нагоді, коли ми почнемо фільтрувати об’єкти даних на основі спостережень, які не відсутні (тобто не є NA).


```r
is.na(1:10)
```

```
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
```

```r
!is.na(1:10)
```

```
##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
```

```r
# Negate(is.na)(1:10) ## Також працює. Спробуйте самі.
```



---

# Логічні операції (прод.)

### Матчінг значень: `%in%`

Щоб побачити, чи міститься об’єкт у списку елементів (тобто відповідає одному з них), використовуйте `%in%`.

```r
4 %in% 1:10
```

```
## [1] TRUE
```

```r
4 %in% 5:10
```

```
## [1] FALSE
```

--

Немає еквівалентної команди «not in», але як ми можемо створити її?
- Підказка: подумайте про заперечення...

--


```r
`%ni%` = Negate(`%in%`) ## (`) допомагає вказати функції.
4 %ni% 5:10
```

```
## [1] TRUE
```

---

# Логічні операції (прод.)

### Порівняння

Ми завжди використовуємо два знаки рівності для логічного порівняння


```r
1 = 1 ## Не працює
```

```
## Error in 1 = 1: invalid (do_set) left-hand side to assignment
```

```r
1 == 1 ## Працює
```

```
## [1] TRUE
```

```r
1 != 2 ## Зверніть увагу на одинарний знак рівності в поєднанні із запереченням.
```

```
## [1] TRUE
```

---

# Логічні операції (прод.)

### Застереження щодо порівняння: числа з плаваючою комою

Як ви думаєте, що буде, якщо ми порівняємо `0.1 + 0.2 == 0.3`?

--


```r
0.1 + 0.2 == 0.3
```

```
## [1] FALSE
```
Ой, лихо!

--

**Проблема.** Комп'ютери представляють числа у двійковій системі з плаваючою комою. Більше [тут](https://floating-point-gui.de/basic/).
- Швидкий і ефективний для пам'яті, але може призвести до несподіваної поведінки.
- Подібно до того, як десятковий дріб не може точно охопити всі значення звичайного дробу (наприклад, `\(\frac{1}{3} = 0,3333...\)`).

--

**Рішення:** Використовуйте `all.equal()` для оцінки числа з плаваючою комою.


```r
all.equal(0.1 + 0.2, 0.3)
```

```
## [1] TRUE
```

---

# Присвоювання

У R ми можемо використовувати або `&lt;-`, або `=` для присвоєння.&lt;sup&gt;1&lt;/sup&gt;

.footnote[
&lt;sup&gt;1&lt;/sup&gt; Стрілка `&lt;-` зписується як знак `&lt;` та `-`. В IDE комбінація клавіш `Alt` та `-`

--

### Присвоювання з `&lt;-`

`&lt;-` ви можете уявити це як стрілку, яка вказує на *напрямок призначення*


```r
a &lt;- 10 + 5
a
```

```
## [1] 15
```

--

Звичайно, стрілка може вказувати і в інший бік (тобто `-&gt;`). Отже, наступний фрагмент коду еквівалентний попередньому, хоча використовується набагато рідше.

```r
10 + 5 -&gt; a
```

---

# Присвоювання (cont.)

### Присвоювання з `=`

Ви також можете використовувати `=` для присвоювання.


```r
b = 10 + 10 ## Зверніть увагу, що об’єкт *повинен* бути ліворуч від знакому "=".
b
```

```
## [1] 20
```

--

### Який оператор присвоєння використовувати?

Більшість користувачів R віддають перевагу `&lt;-` для присвоєння, оскільки `=` також має особливу роль *в межах* функцій.

**Підсумок:** Якщо Ви пишите на R, краще використовувати `&lt;-`, хоча й `=` в більшості випадків не є проблемою. Просто будьте послідовними.

---

# Справка

Щоб отримати додаткову інформацію про (іменовану) функцію або об’єкт у R, зверніться до «довідкової» документації. Наприклад:

```R
help(plot)
```

Або просто використовуйте `?`:
  
```R
?plot 
```

Або клацніть в назву функції і натисніть на `F1` або `Fn + F1` (в залежності від налаштувань ОС)

--

**Доповнення 1:** Коментарі в R записуються після знаку `#`. 
- Натисніть `Ctrl+Shift+c` в RStudio для (роз)коментування вибраного коду.

--

**Доповнення 2:** Бачите розділ *Examples* внизу довідки?
- Ви можете запустити їх за допомогою функції `example()`. Спробуйте: `example(plot)`.

---

# Справка (прод.)

### Віньєтки

Для багатьох пакетах ви також можете спробувати функцію `vignette()`, яка демонструє основний функціонал пакету та низку корисних пракладів.
- Спробуйте зараз запустити `vignette("dplyr")` у своїй консолі.

--

Я дуже рекомендую читати віньєтоки до пакетів, якщо вони доступні.
– Часто вони є найкращим способом навчитися користуватися пакетом.

--

Одна з проблем полягає в тому, що вам потрібно знати точну назву віньєтки(ок) пакету.
- Напр.: Пакет `dplyr` насправді має кілька віньєток, пов'язаних з ним: "dplyr", "window-functions", "programming" тощо.
- Ви можете запустити `vignette()` (тобто без будь-яких аргументів), щоб вивести список доступних віньєток кожного *встановленого* пакета.
- Або запустіть `vignette(all = FALSE)`, якщо ви хочете побачити лише віньєтки *завантажених* пакетів.

---

# Справка (cont.)

### Демонстрації

Як і віньєтки, багато пакетів мають вбудовані інтерактивні демонстрації.

Щоб переглянути всі доступні демонстрації у вашій системі:

```r
demo(package = .packages(all.available = TRUE))
```
--

Щоб запустити конкретну демонстрацію, просто скажіть R, який із них, і назву батьківського пакета. Наприклад:

```r
demo("graphics", package = "graphics")
```

---
class: inverse, center, middle
name: oop

# ООП в R

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1100px&gt;&lt;/html&gt;

---

# Мотивація

У нашій першій лекції я згадав підхід R до [об’єктно-орієнтованого програмування](https://en.wikipedia.org/wiki/Object-oriented_programming) (OOP), який часто підсумовується так:

&gt; **"Все є об’єктом і все має назву."**

--

У наступних двох розділах я хочу трохи детальніше зануритися в цю ідею. Я також хочу попередити деякі проблеми, які можуть завадити вам, якщо ви вперше в R або OOP загалом.

--

Хороша новина полягає в тому, що уникнути та вирішити ці проблеми досить просто.

---

# Дисклеймер

Найочевидніше, що в R насправді існує _кілька_ фреймворків ООП.
- **S3**, **S4**, **R6**...
– «Advanced R» Хедлі Вікхема містить [дуже ретельний огляд](https://adv-r.hadley.nz/oo.html).

---
class: inverse, center, middle
name: eobject

# "Все є об’єктом"
&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1100px&gt;&lt;/html&gt;

---

# Що таке об’єкти?

Важливо підкреслити, що існує багато різних *типів* (або *класів*) об'єктів.

Ми знову розглянемо питання "тип" і "клас" на кількох слайдах. На даний момент корисно просто назвати деякі об’єкти, з якими ми будемо працювати регулярно:
- вектори (*vectors*)
- матриці (*matrices*)
- дата фрейми (*data frames*)
- списки (*lists*)
- функції (*functions*)
- тощо.

--

Швидше за все, ви вже добре уявляєте, чим відрізняються ці об’єкти і як ними користуватися.
- Однак майте на увазі, що є тонкощі, які можуть заплутати, поки ви ще звикнете до R.
- Напр. Існують різні види фреймів даних. Незабаром ми зустрінемо "[tibbles](https://tibble.tidyverse.org/)" і "[data.tables](https://rdatatable.gitlab.io/data.table/articles/datatable-intro. html#what-is-datatable-1a)", які є розширеними версіями стандартного фрейму даних у R.

---

# Що таке об’єкти? (прод.)

Кожен клас об’єктів має власний набір правил («методів») для визначення дійсних операцій.
- Наприклад, можна виконувати багато тих самих операцій над матрицями та дата фреймами. Але є деякі операції, які працюють лише з матрицею, і навпаки.
- У той же час ви можете (зазвичай) перетворити об'єкт з одного типу в інший.


```r
## Створіть невеликий дата фрейм під назвою «d».
d &lt;- data.frame(x = 1:2, y = 3:4) 
d
```

```
##   x y
## 1 1 3
## 2 2 4
```


```r
## Перетворіть його в матрицю "m".
m &lt;- as.matrix(d)
m
```

```
##      x y
## [1,] 1 3
## [2,] 2 4
```

---

# Клас, тип і структура об’єкта

Використовуйте команди `class`, `typeof` та `str`, якщо хочете більше дізнатися про конкретні об'єкти.


```r
# d &lt;- data.frame(x = 1:2, y = 3:4) ## Створіть невеликий дата фрейм під назвою «d».
class(d) ## Оцініть його клас.
```

```
## [1] "data.frame"
```

```r
typeof(d) ## Оцініть його тип.
```

```
## [1] "list"
```

```r
str(d) ## Показати його структуру.
```

```
## 'data.frame':	2 obs. of  2 variables:
##  $ x: int  1 2
##  $ y: int  3 4
```

--

PS — Вас бентежить той факт, що `typeof(d)` повертає "list"? Дивіться [тут](https://stackoverflow.com/questions/45396538/typeofdata-frame-shows-list-in-r).

---

# Клас, тип і структура об’єкта (прод.)

Звичайно, ви завжди можете просто перевірити/роздрукувати об’єкт безпосередньо в консолі.
- Напр. введіть `d` і натисніть Enter.


Функція `View()` також дуже корисна. Це те саме, що клацнути об’єкт у вашій області RStudio *Environment*. (Спробуйте обидва способи зараз.)
- Напр. `View(d)`.

---
name: global_env

# Глобальне середовище (*global environment*)

Давайте повернемося до простого дата фрейму, який ми створили кількома слайдами раніше.

```r
d
```

```
##   x y
## 1 1 3
## 2 2 4
```

--

Тепер давайте спробуємо запустити регресію&lt;sup&gt;1&lt;/sup&gt; для цих змінних "x" і "y":

.footnote[
&lt;sup&gt;1&lt;/sup&gt; Так, це примітивна регресія з ідеально колінеарними змінними. Просто живіть з цим :) 
]


```r
lm(y ~ x) ## "lm" означає лінійну модель(и)
```

```
## Error in eval(predvars, data, env): object 'y' not found
```

--

Ой-ой. Що тут пішло не так? (Відповідь на наступному слайді.)

---

# Глобальне середовище (прод.)

Повідомлення про помилку дає відповідь на наше запитання:

```
*## Error in eval(predvars, data, env): object 'y' not found
```

--

R не може знайти змінні, які ми створили в нашому [Глобальному середовищі](https://www.datamentor.io/r-programming/environment-scope/):

![Ні "x" ні "y" тут не має...](pics/environment.png){width=50%}

--

Іншими словами: оскільки змінні "x" і "y" живуть як окремі об'єкти в глобальному середовищі, ми повинні сказати R, що вони належать об'єкту `d`.
- Подумайте, як це зробити, перш ніж переходити до наступного слайда.

---

# Глобальне середовище (прод.)

Існують різні способи вирішення цієї проблеми. Один із них — просто вказати джерело даних:


```r
lm(y ~ x, data = d) ## Працює, коли ми додаємо "data = d"!
```

```
## 
## Call:
## lm(formula = y ~ x, data = d)
## 
## Coefficients:
## (Intercept)            x  
##           2            1
```

--

Я хотів наголосити на цій глобальній проблемі навколишнього середовища, тому що користувачі Stata (тобто багато економістів) борються з цим, коли вперше приходять до R.
- У Stata весь робочий простір по суті складається з одного (і лише одного) фрейма даних. Отже, не може бути двозначності, звідки походять змінні.
– Однак ця «зручність» має дійсно високу ціну, ІМО. Ви ніколи не зможете прочитати в пам’ять більше двох окремих наборів даних (не кажучи вже про типи об’єктів) одночасно, вам доведеться використовувати всілякі хаки, щоб додати підсумкові змінні до вашого набору даних тощо.
- Якщо говорити про це...


---

# Робота з кількома об’єктами

Як я постійно кажу, здатність R зберігати в пам’яті кілька об’єктів одночасно є величезним плюсом, коли справа доходить до ефективної роботи з даними.
- Напр. Ми можемо скопіювати вихідний фрейм даних або створити новий повністю з нуля. Будь-який з наших існуючих об’єктів буде щасливо існувати в глобальному середовищі.


```r
d2 &lt;- data.frame(x = rnorm(10), y = runif(10))
```

![Тепер із доданим d2](pics/environment2.png){width=50%}

---

# Робота з кількома об’єктами (прод.)

Знову ж таки, це означає, що ви повинні звернути увагу на назви цих окремих дата фреймів і точно визначити, на які об’єкти ви посилаєтеся.
- Ми хочемо запустити регресію "y" на "x" з дата фрейму `d` або дата фрейму `d2`?

---
class: inverse, center, middle
name: ename

# "Все має назву"

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1100px&gt;&lt;/html&gt;

---

# Зарезервовані слова

Ми побачили, що ми можемо призначати об’єктам різні імена. Однак є ряд спеціальних слів, які «зарезервовані» в R.
- Це основні команди, оператори та відносини в базі R, які ви не можете (пере)призначити, навіть якщо захочете.
– Ми вже стикалися з прикладами з логічними операторами.

Дивіться [тут](http://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html) для отримання повного списку:

```R
if 
else 
while 
function 
for
TRUE 
FALSE 
NULL 
Inf 
NaN 
NA 
```

---

# Напів-зарезервовані слова

На додаток до списку суворо зарезервованих слів є клас слів і рядків, які я збираюся назвати «напівзарезервованими».
- Це іменовані функції або константи (наприклад, `pi`), які ви можете повторно перепризначити, якщо дійсно це потрібно...але вони посідають важливе місце в основі R.

Мабуть, найважливішим напівзарезервованим символом є `c()`, який ми використовуємо для конкатенації; тобто створення векторів і зв’язування різних об’єктів разом.


```r
my_vector &lt;- c(1, 2, 5)
my_vector
```

```
## [1] 1 2 5
```

--

Що станеться, якщо ви введете наступне? (Спробуйте на своїй консолі.)

```R
c &lt;- 4
c(1, 2 ,5)
```
--

Як так-то???

Вектори дуже важливі в R, тому що мова була оптимізована для них. Не турбуйтеся про це зараз; пізніше ви дізнаєтеся, що я маю на увазі під «векторизацією» функції.


---

# Напів-зарезервовані слова (прод.)

*(Продовження з попереднього слайда.)*

У цьому випадку, на щастя, нічого. R є достатньо «розумним», щоб розрізняти створену нами змінну `c &lt;- 4` та вбудовану функцію `c()`, яка вимагає конкатенації.

--

Однак це все ще *надзвичайно* неакуратне кодування. R не завжди зможе розрізнити суперечливі визначення. І ви теж не будете. Наприклад:

```r
pi
```

```
## [1] 3.141593
```

```r
pi &lt;- 2
pi
```

```
## [1] 2
```
--

**Підсумок:** Не використовуйте (напів)зарезервовані символи!

---

# Конфлікти простору імен

Подібна проблема виникає, коли ми завантажуємо два пакети, які мають функції з однаковою назвою. напр. Подивіться, що відбувається, ми завантажуємо пакет `dplyr`.

```r
library(dplyr)
```

```
## Warning: package 'dplyr' was built under R version 4.1.2
```

```
## 
## Attaching package: 'dplyr'
```

```
## The following objects are masked from 'package:stats':
## 
##     filter, lag
```

```
## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union
```

--

Повідомлення, які ви бачите про те, що якийсь об’єкт *masked from 'package:X*, попереджають про конфлікт простору імен.
- Напр. І `dplyr`, і пакет `stats` (який завантажується автоматично під час запуску R) мають функції з іменами "filter" і "lag".

---

# Конфлікти простору імен (прод.)

Можливість конфліктів простору імен є результатом підходу ООП.&lt;sup&gt;1&lt;/sup&gt;
- Також відображає фундаментальну природу R з відкритим вихідним кодом і використання зовнішніх пакетів. Люди можуть називати свої функції як завгодно, тому можна очікувати деякого накладання.

.footnote[
&lt;sup&gt;1&lt;/sup&gt; Подібні проблеми виникають практично в кожній іншій мові програмування (Python, C тощо).
]

--

Щоразу, коли виникає конфлікт простору імен, перевагу надаватиметься останньому завантаженому пакету. Отже, функція `filter()` тепер посилається саме на варіант `dplyr`.

Але що, якщо нам потрібен варіант `stats`? Ну, у нас є два варіанти:
1. Тимчасово використовуйте `stats::filter()`
2. Назавжди призначте `filter &lt;- stats::filter`

---

# Вирішення конфліктів простору імен

### 1. Використовуйте `package::function()`

Ми можемо явно викликати конфліктну функцію з конкретного пакета, використовуючи синтаксис `package::function()`. Наприклад:

```r
stats::filter(1:10, rep(1, 2))
```

```
## Time Series:
## Start = 1 
## End = 10 
## Frequency = 1 
##  [1]  3  5  7  9 11 13 15 17 19 NA
```

--

Ми також можемо використовувати `::` не тільки для конфліктних випадків.
- Напр. якщо чітко пояснити, звідки походить функція (або набір даних), це може допомогти додати чіткості нашому коду. Спробуйте ці рядки коду на консолі R.

```R
dplyr::starwars ## Роздрукуйте дата фрейм starwars з пакета dplyr
scales::comma(c(1000, 1000000)) ## Використовуйте функцію коми, яка входить до пакета scales
```

Синтаксис `::` також означає, що ми можемо викликати функції без попереднього завантаження пакета. напр. поки `dplyr` встановлений у нашій системі, `dplyr::filter(iris, Species=="virginica")` працюватиме.
  
---

# Вирішення конфліктів простору імен (прод.)

### 2. Призначити `function &lt;- package::function`
  
Більш постійне рішення — призначити конфліктну назву функції певному пакету. Це буде діяти до кінця вашого поточного сеансу R або поки ви не зміните його назад. напр.

```r
filter &lt;- stats::filter ## Зверніть увагу на відсутність дужок.
filter &lt;- dplyr::filter ## Змінить його знову.
```

--

### Загальні поради

Я б загалом виступаю за тимчасове рішення `package::function()`.

Ще одне практичне правило: завантажуйте найважливіші пакети в останню чергу. (Наприклад, завантажте `tidyverse` після того, як ви вже завантажили будь-які інші пакети)
  
Крім цього, просто зверніть увагу на будь-які попередження під час завантаження нового пакета, і `?` є вашим другом, якщо ви не впевнені. (Наприклад, `?filter` скаже вам, який варіант використовується.)
- Насправді, проблематичні конфлікти простору імен трапляються рідко. Але добре знати про них.
  
---

# Конфлікти простору імен на стороні користувача

Останнє, що можна сказати про конфлікти простору імен, це те, що вони виникають не тільки в результаті завантаження пакетів. Вони можуть виникнути, коли користувачі створюють власні функції з конфліктуючими іменами.
- Напр. якби я був достатньо наївним, щоб створити нову функцію під назвою `c()`.

--

&lt;/br&gt;

Подібним чином одна з найпоширеніших і заплутаних помилок, з якою стикаються навіть досвідчені R-програмісти, пов’язана зі звичкою називати об’єкти «df» або «data»... обидва вони є функціями в базі R!
- Переконайтеся в цьому, ввівши `?df` або `?data`.

Знову ж таки, R зрозуміє, що ви маєте на увазі, якщо вам пощастило. Але, як і з `c()`, відносно легко зіткнутися з проблемами.
- Показовий приклад: запуск сумнозвісного повідомлення про помилку "object of type closure is not subsettable". (Див. з 1:45 [тут](https://rstudio.com/resources/rstudioconf-2020/object-of-type-closure-is-not-subsettable/).)

---
class: inverse, center, middle
name: indexing

# Індексація

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1100px&gt;&lt;/html&gt;
  
---

# Варіант 1: []

Ми вже бачили приклад індексації у вигляді виводу консолі R. Наприклад:

```r
1+2
```

```
## [1] 3
```

"[1]" вище позначає перший (і в даному випадку єдиний) елемент нашого виводу. У цьому випадку вектор довжини один дорівнює значенню "3".

--
.pull-left[
Спробуйте наступне на консолі, щоб побачити більш чіткий приклад індексованого виводу:

```r
rnorm(n = 100, mean = 0, sd = 1)
```


**Індексація в R починається з 1. Не 0, як у деяких мовах (наприклад, Python і JavaScript).**
]
.pull-right[
![](pics/r_py_index.png)
]

---

# Варіант 1: [] (прод.)


Що ще важливіше, ми також можемо використовувати `[]` для індексації об'єктів, які ми створюємо в R.

```r
a = 1:10
a[4] ## Отримати 4-й елемент об'єкта "a"
```

```
## [1] 4
```

```r
a[c(4, 6)] ## Отримайте 4-й і 6-й елементи
```

```
## [1] 4 6
```

Він також працює з великими масивами (векторами, матрицями, дата фреймами і списками). Наприклад:

```r
starwars[1, 1] ## Покажіть спостереження, що відповідає 1-му рядку та 1-му стовпцю дата фрейму.
```

```
## # A tibble: 1 x 1
##   name          
##   &lt;chr&gt;         
## 1 Luke Skywalker
```

--

Що дасть `starwars[1:3, 1]`?

---

# Варіант 1: [] (прод.)

Ми ще не розглянули їх належним чином (терпіння), але **списки** є більш складним типом об’єкта масиву в R.
- Вони можуть містити випадковий асортимент об’єктів, які не мають однакового класу або мають однакову форму (наприклад, ранг) або спільну структуру.
- Напр. cписок може містити скаляр, рядок і фрейм даних. Або ви можете мати список фреймів даних або навіть списки списків.

--

Релевантність індексації полягає в тому, що списки вимагають двох квадратних дужок `[[]]`, щоб індексувати "батьківський" елемент списку, а потім стандартний `[]` у цьому "батьківському" елементі. Приклад може допомогти проілюструвати:

```r
my_list = list(a = "hello", b = c(1,2,3), c = data.frame(x = 1:5, y = 6:10))
my_list[[1]] ## Повернути 1-й об’єкт списку
```

```
## [1] "hello"
```

```r
my_list[[2]][3] ## Повертає 3-й елемент 2-го об’єкта списку
```

```
## [1] 3
```

---

# Варіант 2: $


Списки забезпечують гарний перехід до нашого іншого оператора індексування: `$`.
- Давайте продовжимо з прикладом `my_list` з попереднього слайда.


```r
my_list
```

```
## $a
## [1] "hello"
## 
## $b
## [1] 1 2 3
## 
## $c
##   x  y
## 1 1  6
## 2 2  7
## 3 3  8
## 4 4  9
## 5 5 10
```

---
count: false

# Варіант 2: $


Списки забезпечують гарний перехід до нашого іншого оператора індексування: `$`.
- Давайте продовжимо з прикладом `my_list` з попереднього слайда.


```r
my_list
```

```
*## $a
## [1] "hello"
## 
*## $b
## [1] 1 2 3
## 
*## $c
##   x  y
## 1 1  6
## 2 2  7
## 3 3  8
## 4 4  9
## 5 5 10
```

Зверніть увагу на те, як розмежовані об'єкти нашого (іменованого) батьківського списку: "$a", "$b" і "$c".

---

# Варіант 2: $ (прод.)

Ми можемо викликати ці об’єкти безпосередньо по імені, використовуючи знак долара, напр.

```r
my_list$a ## Повернути об'єкт "a" зі списку
```

```
## [1] "hello"
```

```r
my_list$b[3] ## Повернути 3-й елемент об'єкта списку "b"
```

```
## [1] 3
```

```r
my_list$c$x ## Повернути стовпець "x" об'єкта списку "c"
```

```
## [1] 1 2 3 4 5
```

--

&lt;/br&gt;

**Нагадування:** Введення `View(my_list)` (або, еквівалентно, клацання об'єкта в області середовища RStudio) забезпечує гарне інтерактивне вікно для вивчення вкладеної структури списків.

---

# Варіант 2: $ (прод.)

Варіант індексування `$` також працює (і так, як ви, ймовірно, очікували) для інших типів об'єктів у R.

У деяких випадках ви також можете комбінувати два параметри індексу.
- Напр. отримайте 1-й елемент стовпця "name" з фрейму даних Starwars.

```r
starwars$name[1]
```

```
## [1] "Luke Skywalker"
```
--

Однак зверніть увагу на деякі ключові відмінності між результатами цього прикладу та результатом нашого попереднього прикладу `starwars[1, 1]`. Які вони?
- Підказка: окрім візуальних підказок, спробуйте обернути кожну команду в `str()`.

---

# Варіант 2: $ (прод.)

Останнє, що я хочу сказати про `$`, це те, що він надає інший спосіб уникнути проблеми "object not found", з якою ми зіткнулися з нашим попереднім прикладом регресії.


```r
lm(y ~ x) ## Не працює
```

```
## Error in eval(predvars, data, env): object 'y' not found
```

```r
lm(d$y ~ d$x) ## Працює!
```

```
## 
## Call:
## lm(formula = d$y ~ d$x)
## 
## Coefficients:
## (Intercept)          d$x  
##           2            1
```

---
class: inverse, center, middle
name: cleaning

# Очищення

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1100px&gt;&lt;/html&gt;

---

# Видалення об’єктів (і пакетів)

Використовуйте `rm()`, щоб видалити об’єкт або об’єкти зі свого робочого середовища.

```r
a &lt;- "hello"
b &lt;- "world"
rm(a, b)
```

Ви також можете використовувати `rm(list = ls())`, щоб видалити всі об’єкти у вашому робочому середовищі (крім пакетів), але це [страшна штука!](https://www.tidyverse.org/articles/2017/12 /workflow-vs-script/). 
- Краще просто почати новий сеанс R.

--

Від’єднання пакетів є складнішим, оскільки існує дуже багато перехресних залежностей (тобто один пакунок залежить від іншого та може навіть автоматично завантажуватись). Однак ви можете спробувати, напр. `detach(package:dplyr)`
- Знову ж таки, краще просто перезапустити сеанс R.
  
---

# Видалення графіків

Ви можете використовувати `dev.off()` для видалення будь-яких (тобто всіх) графіків, які були згенеровані під час вашого сеансу. Наприклад, спробуйте це у своїй консолі R:

```r
plot(1:10)
dev.off()
```

--

Ви також могли помітити, що у RStudio є зручні кнопки для очищення робочого середовища та видалення (окремих) графіків. Просто знайдіть ці піктограми у відповідних віконних панелях:

![](pics/broom.png?display=inline-block)

---

class: inverse, center, middle

# Наступна лекція: Чистка та обробка даних

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=1100px&gt;&lt;/html&gt;



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
